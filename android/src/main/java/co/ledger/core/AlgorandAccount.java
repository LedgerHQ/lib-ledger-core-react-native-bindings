// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from idl.djinni

package co.ledger.core;

import java.util.concurrent.atomic.AtomicBoolean;

public abstract class AlgorandAccount {
    /**
     * Get the maximum amount spendable in one transaction
     * @param callback, Callback returning the maximum amount spendable
     * @param operationType, the type of the operation
     */
    public abstract void getSpendableBalance(AlgorandOperationType operationType, AmountCallback callback);

    /**
     * Get information about a specific asset
     * @param assetId, the unique identifier of the asset to look for
     * @param callback, Callback returning the information about the queried asset
     */
    public abstract void getAsset(String assetId, AlgorandAssetParamsCallback callback);

    /**
     * Check if address has a specific asset
     * @param address, the address to check
     * @param assetId, the unique identifier of the asset to look for
     * @param callback, Callback returning the true if the address hold the asset
     */
    public abstract void hasAsset(String address, String assetId, BoolCallback callback);

    /**
     * Check if address can receive the given amount:
     * it may not be enough to reach the minimum balance, if the account has 0 ALGO
     * @param address, the address to check
     * @param amount, the amount to test
     * @param callback, Callback returning the true if the address hold the asset
     */
    public abstract void isAmountValid(String address, String amount, BoolCallback callback);

    /**
     * Get balance of account for a particular asset.
     * @param assetId, the unique identifier of the asset on the algorand network
     * @param callback, if getAssetBalance succeeds, Callback returning an Amount object which represents account's balance
     */
    public abstract void getAssetBalance(String assetId, AlgorandAssetAmountCallback callback);

    /**
     * Get balance of account for a particular asset at a precise interval with a certain granularity
     * @param assetId, the unique identifier of the asset on the algorand network
     * @param start, lower bound of search range
     * @param end, upper bound of search range
     * @param precision, granularity at which we want results
     * @param callback, ListCallback returning a list of Amount objects which represents account's balance
     */
    public abstract void getAssetBalanceHistory(String assetId, String start, String end, TimePeriod period, AlgorandAssetAmountListCallback callback);

    /**
     * Get balances of all assets to which account is registered
     * @param callback, ListCallback returning a list of AlgorandAssetAmount objects representing the different balances
     */
    public abstract void getAssetsBalances(AlgorandAssetAmountListCallback callback);

    /**
     * Get information about the assets created by account
     * @param callback, ListCallback returning a list of AlgorandAssetParams objects representing the assets created by account
     */
    public abstract void getCreatedAssets(AlgorandAssetParamsListCallback callback);

    /**
     * Get the pending rewards for account
     * @param callback, Callback returning the amount of pending rewards in MicroAlgos
     */
    public abstract void getPendingRewards(AmountCallback callback);

    /**
     * Get the total rewards of MicroAlgos account has received, including pending rewards.
     * @param callback, Callback returning the total rewards in MicroAlgos.
     */
    public abstract void getTotalRewards(AmountCallback callback);

    /**
     * Get an estimation (in MicroAlgos) of the fees needed to broadcast a given transaction to the algorand network
     * @param transaction, the transaction for which fees are estimated
     * @param callback, Callback returning the fees in MicroAlgos for the specified transaction
     */
    public abstract void getFeeEstimate(AlgorandTransaction transaction, AmountCallback callback);

    /**
     * Build a raw signed transaction from a raw unsigned transaction and the signature
     * @param rawUnsignedTransaction, the msgpack-encoded unsigned transaction
     * @param signature, the signature of the transaction
     * @return binary, the msgpack-encoded signed transaction
     */
    public abstract byte[] buildRawSignedTransaction(byte[] rawUnsignedTransaction, byte[] signature);

    /**
     * Broadcast a raw transaction to the algorand network
     * @param transaction, the msgpack-encoded transaction
     * @param callback, Callback returning the id of the transaction in case of success, an error message otherwise
     */
    public abstract void broadcastRawTransaction(byte[] transaction, StringCallback callback);

    /**
     * Broadcast an AlgorandTransaction object to the algorand network
     * @param transaction, the transaction to broadcast
     * @param callback, Callback returning the fees in MicroAlgos for the specified transaction
     */
    public abstract void broadcastTransaction(AlgorandTransaction transaction, StringCallback callback);

    /**
     * Create a new transaction
     * @param callback, The new transaction
     */
    public abstract void createTransaction(AlgorandTransactionCallback callback);
    /** Release the underlying native object */
    public abstract void destroy();


    private static final class CppProxy extends AlgorandAccount
    {
        private final long nativeRef;
        private final AtomicBoolean destroyed = new AtomicBoolean(false);

        private CppProxy(long nativeRef)
        {
            if (nativeRef == 0) throw new RuntimeException("nativeRef is zero");
            this.nativeRef = nativeRef;
        }

        private native void nativeDestroy(long nativeRef);
        @Override
        public void destroy()
        {
            boolean destroyed = this.destroyed.getAndSet(true);
            if (!destroyed) nativeDestroy(this.nativeRef);
        }
        protected void finalize() throws java.lang.Throwable
        {
            destroy();
            super.finalize();
        }

        @Override
        public void getSpendableBalance(AlgorandOperationType operationType, AmountCallback callback)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            native_getSpendableBalance(this.nativeRef, operationType, callback);
        }
        private native void native_getSpendableBalance(long _nativeRef, AlgorandOperationType operationType, AmountCallback callback);

        @Override
        public void getAsset(String assetId, AlgorandAssetParamsCallback callback)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            native_getAsset(this.nativeRef, assetId, callback);
        }
        private native void native_getAsset(long _nativeRef, String assetId, AlgorandAssetParamsCallback callback);

        @Override
        public void hasAsset(String address, String assetId, BoolCallback callback)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            native_hasAsset(this.nativeRef, address, assetId, callback);
        }
        private native void native_hasAsset(long _nativeRef, String address, String assetId, BoolCallback callback);

        @Override
        public void isAmountValid(String address, String amount, BoolCallback callback)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            native_isAmountValid(this.nativeRef, address, amount, callback);
        }
        private native void native_isAmountValid(long _nativeRef, String address, String amount, BoolCallback callback);

        @Override
        public void getAssetBalance(String assetId, AlgorandAssetAmountCallback callback)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            native_getAssetBalance(this.nativeRef, assetId, callback);
        }
        private native void native_getAssetBalance(long _nativeRef, String assetId, AlgorandAssetAmountCallback callback);

        @Override
        public void getAssetBalanceHistory(String assetId, String start, String end, TimePeriod period, AlgorandAssetAmountListCallback callback)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            native_getAssetBalanceHistory(this.nativeRef, assetId, start, end, period, callback);
        }
        private native void native_getAssetBalanceHistory(long _nativeRef, String assetId, String start, String end, TimePeriod period, AlgorandAssetAmountListCallback callback);

        @Override
        public void getAssetsBalances(AlgorandAssetAmountListCallback callback)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            native_getAssetsBalances(this.nativeRef, callback);
        }
        private native void native_getAssetsBalances(long _nativeRef, AlgorandAssetAmountListCallback callback);

        @Override
        public void getCreatedAssets(AlgorandAssetParamsListCallback callback)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            native_getCreatedAssets(this.nativeRef, callback);
        }
        private native void native_getCreatedAssets(long _nativeRef, AlgorandAssetParamsListCallback callback);

        @Override
        public void getPendingRewards(AmountCallback callback)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            native_getPendingRewards(this.nativeRef, callback);
        }
        private native void native_getPendingRewards(long _nativeRef, AmountCallback callback);

        @Override
        public void getTotalRewards(AmountCallback callback)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            native_getTotalRewards(this.nativeRef, callback);
        }
        private native void native_getTotalRewards(long _nativeRef, AmountCallback callback);

        @Override
        public void getFeeEstimate(AlgorandTransaction transaction, AmountCallback callback)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            native_getFeeEstimate(this.nativeRef, transaction, callback);
        }
        private native void native_getFeeEstimate(long _nativeRef, AlgorandTransaction transaction, AmountCallback callback);

        @Override
        public byte[] buildRawSignedTransaction(byte[] rawUnsignedTransaction, byte[] signature)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            return native_buildRawSignedTransaction(this.nativeRef, rawUnsignedTransaction, signature);
        }
        private native byte[] native_buildRawSignedTransaction(long _nativeRef, byte[] rawUnsignedTransaction, byte[] signature);

        @Override
        public void broadcastRawTransaction(byte[] transaction, StringCallback callback)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            native_broadcastRawTransaction(this.nativeRef, transaction, callback);
        }
        private native void native_broadcastRawTransaction(long _nativeRef, byte[] transaction, StringCallback callback);

        @Override
        public void broadcastTransaction(AlgorandTransaction transaction, StringCallback callback)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            native_broadcastTransaction(this.nativeRef, transaction, callback);
        }
        private native void native_broadcastTransaction(long _nativeRef, AlgorandTransaction transaction, StringCallback callback);

        @Override
        public void createTransaction(AlgorandTransactionCallback callback)
        {
            if (this.destroyed.get())
            {
                throw new RuntimeException("trying to use a destroyed object (AlgorandAccount)");
            }
            native_createTransaction(this.nativeRef, callback);
        }
        private native void native_createTransaction(long _nativeRef, AlgorandTransactionCallback callback);
    }
}
