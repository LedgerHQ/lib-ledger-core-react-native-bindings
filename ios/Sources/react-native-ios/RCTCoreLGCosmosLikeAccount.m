// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from wallet.djinni

#import "RCTCoreLGCosmosLikeAccount.h"


@implementation RCTCoreLGCosmosLikeAccount
//Export module
RCT_EXPORT_MODULE(RCTCoreLGCosmosLikeAccount)

@synthesize bridge = _bridge;


+ (BOOL)requiresMainQueueSetup
{
    return NO;
}
RCT_REMAP_METHOD(release, release:(NSDictionary *)currentInstance withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    [self baseRelease:currentInstance withResolver: resolve rejecter:reject];
}
RCT_REMAP_METHOD(log, logWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    [self baseLogWithResolver:resolve rejecter:reject];
}
RCT_REMAP_METHOD(flush, flushWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    [self baseFlushWithResolver:resolve rejecter:reject];
}
RCT_REMAP_METHOD(isNull, isNull:(NSDictionary *)currentInstance withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    [self baseIsNull:currentInstance withResolver:resolve rejecter:reject];
}

RCT_REMAP_METHOD(broadcastRawTransaction,broadcastRawTransaction:(NSDictionary *)currentInstance withParams:(nonnull NSString *)transaction withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::broadcastRawTransaction, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::broadcastRawTransaction, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGStringCallback *objcParam_1 = [[RCTCoreLGStringCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj broadcastRawTransaction:transaction callback:objcParam_1];

}

RCT_REMAP_METHOD(broadcastTransaction,broadcastTransaction:(NSDictionary *)currentInstance withParams:(NSDictionary *)transaction withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::broadcastTransaction, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::broadcastTransaction, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGCosmosLikeTransaction *rctParam_transaction = (RCTCoreLGCosmosLikeTransaction *)[self.bridge moduleForName:@"CoreLGCosmosLikeTransaction"];
    LGCosmosLikeTransaction *objcParam_0 = (LGCosmosLikeTransaction *)[rctParam_transaction.objcImplementations objectForKey:transaction[@"uid"]];
    RCTCoreLGStringCallback *objcParam_1 = [[RCTCoreLGStringCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj broadcastTransaction:objcParam_0 callback:objcParam_1];

}

RCT_REMAP_METHOD(buildTransaction,buildTransaction:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::buildTransaction, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::buildTransaction, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    LGCosmosLikeTransactionBuilder * objcResult = [currentInstanceObj buildTransaction];

    NSString *objcResult_uuid = [[NSUUID UUID] UUIDString];
    RCTCoreLGCosmosLikeTransactionBuilder *rctImpl_objcResult = (RCTCoreLGCosmosLikeTransactionBuilder *)[self.bridge moduleForName:@"CoreLGCosmosLikeTransactionBuilder"];
    NSArray *objcResult_array = [[NSArray alloc] initWithObjects:objcResult, objcResult_uuid, nil];
    [rctImpl_objcResult baseSetObject:objcResult_array];
    NSDictionary *result = @{@"type" : @"CoreLGCosmosLikeTransactionBuilder", @"uid" : objcResult_uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGCosmosLikeAccount::buildTransaction", nil);
        return;
    }

}

/** Get estimated gas limit to set so the transaction will succeed */
RCT_REMAP_METHOD(getEstimatedGasLimit,getEstimatedGasLimit:(NSDictionary *)currentInstance withParams:(NSDictionary *)transaction withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getEstimatedGasLimit, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getEstimatedGasLimit, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGCosmosLikeTransaction *rctParam_transaction = (RCTCoreLGCosmosLikeTransaction *)[self.bridge moduleForName:@"CoreLGCosmosLikeTransaction"];
    LGCosmosLikeTransaction *objcParam_0 = (LGCosmosLikeTransaction *)[rctParam_transaction.objcImplementations objectForKey:transaction[@"uid"]];
    RCTCoreLGBigIntCallback *objcParam_1 = [[RCTCoreLGBigIntCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getEstimatedGasLimit:objcParam_0 callback:objcParam_1];

}

/**
 * Ask the account to estimate the gas for a building transaction
 * This function uses the underlying infrastructure to simulate the gas
 * needed for the transaction as requested until now.
 * @param request is the CosmosGasLimitRequest for the specifics of the simulation
 */
RCT_REMAP_METHOD(estimateGas,estimateGas:(NSDictionary *)currentInstance withParams:(NSDictionary *)buildingTx withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::estimateGas, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::estimateGas, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGCosmosGasLimitRequest *rctParam_buildingTx = (RCTCoreLGCosmosGasLimitRequest *)[self.bridge moduleForName:@"CoreLGCosmosGasLimitRequest"];
    LGCosmosGasLimitRequest *objcParam_0 = (LGCosmosGasLimitRequest *)[rctParam_buildingTx.objcImplementations objectForKey:buildingTx[@"uid"]];
    RCTCoreLGBigIntCallback *objcParam_1 = [[RCTCoreLGBigIntCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj estimateGas:objcParam_0 callback:objcParam_1];

}

/** Get the latest active validator set */
RCT_REMAP_METHOD(getLatestValidatorSet,getLatestValidatorSet:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getLatestValidatorSet, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getLatestValidatorSet, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGCosmosLikeValidatorListCallback *objcParam_0 = [[RCTCoreLGCosmosLikeValidatorListCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getLatestValidatorSet:objcParam_0];

}

/** Get information about one validator */
RCT_REMAP_METHOD(getValidatorInfo,getValidatorInfo:(NSDictionary *)currentInstance withParams:(nonnull NSString *)validatorAddress withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getValidatorInfo, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getValidatorInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGCosmosLikeValidatorCallback *objcParam_1 = [[RCTCoreLGCosmosLikeValidatorCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getValidatorInfo:validatorAddress callback:objcParam_1];

}

/** Get Total balance of account. Sum of spendable, delegated, pending rewards, and pending unbondings */
RCT_REMAP_METHOD(getTotalBalance,getTotalBalance:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getTotalBalance, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getTotalBalance, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGAmountCallback *objcParam_0 = [[RCTCoreLGAmountCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getTotalBalance:objcParam_0];

}

/** Get Total amount in delegation of account. */
RCT_REMAP_METHOD(getDelegatedBalance,getDelegatedBalance:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getDelegatedBalance, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getDelegatedBalance, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGAmountCallback *objcParam_0 = [[RCTCoreLGAmountCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getDelegatedBalance:objcParam_0];

}

/** Get Total pending rewards of account. */
RCT_REMAP_METHOD(getPendingRewardsBalance,getPendingRewardsBalance:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getPendingRewardsBalance, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getPendingRewardsBalance, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGAmountCallback *objcParam_0 = [[RCTCoreLGAmountCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getPendingRewardsBalance:objcParam_0];

}

/** Get Total unbondings funds of account. */
RCT_REMAP_METHOD(getUnbondingBalance,getUnbondingBalance:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getUnbondingBalance, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getUnbondingBalance, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGAmountCallback *objcParam_0 = [[RCTCoreLGAmountCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getUnbondingBalance:objcParam_0];

}

/** Get Total spendable balance of account. */
RCT_REMAP_METHOD(getSpendableBalance,getSpendableBalance:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getSpendableBalance, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getSpendableBalance, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGAmountCallback *objcParam_0 = [[RCTCoreLGAmountCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getSpendableBalance:objcParam_0];

}

RCT_REMAP_METHOD(getDelegations,getDelegations:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getDelegations, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getDelegations, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGCosmosLikeDelegationListCallback *objcParam_0 = [[RCTCoreLGCosmosLikeDelegationListCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getDelegations:objcParam_0];

}

RCT_REMAP_METHOD(getPendingRewards,getPendingRewards:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getPendingRewards, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getPendingRewards, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGCosmosLikeRewardListCallback *objcParam_0 = [[RCTCoreLGCosmosLikeRewardListCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getPendingRewards:objcParam_0];

}

RCT_REMAP_METHOD(getUnbondings,getUnbondings:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getUnbondings, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getUnbondings, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGCosmosLikeUnbondingListCallback *objcParam_0 = [[RCTCoreLGCosmosLikeUnbondingListCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getUnbondings:objcParam_0];

}

RCT_REMAP_METHOD(getRedelegations,getRedelegations:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getRedelegations, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getRedelegations, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGCosmosLikeRedelegationListCallback *objcParam_0 = [[RCTCoreLGCosmosLikeRedelegationListCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getRedelegations:objcParam_0];

}

/**
 * Get the current account sequence (synchronize to get latest value)
 * string like "14"
 */
RCT_REMAP_METHOD(getSequence,getSequence:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getSequence, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getSequence, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGStringCallback *objcParam_0 = [[RCTCoreLGStringCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getSequence:objcParam_0];

}

/**
 * Get the account number
 * String like "15"
 */
RCT_REMAP_METHOD(getAccountNumber,getAccountNumber:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getAccountNumber, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getAccountNumber, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGStringCallback *objcParam_0 = [[RCTCoreLGStringCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getAccountNumber:objcParam_0];

}

/**
 * Get the rewards withdrawal address
 * String Bech32 encoded string
 */
RCT_REMAP_METHOD(getWithdrawAddress,getWithdrawAddress:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGCosmosLikeAccount::getWithdrawAddress, first argument should be an instance of LGCosmosLikeAccount", nil);
        return;
    }
    LGCosmosLikeAccount *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGCosmosLikeAccount::getWithdrawAddress, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGStringCallback *objcParam_0 = [[RCTCoreLGStringCallback alloc] initWithResolver:resolve rejecter:reject andBridge:self.bridge];
    [currentInstanceObj getWithdrawAddress:objcParam_0];

}
@end
