// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from idl.djinni

#import "RCTCoreLGAlgorandTransaction.h"


@implementation RCTCoreLGAlgorandTransaction
//Export module
RCT_EXPORT_MODULE(RCTCoreLGAlgorandTransaction)

@synthesize bridge = _bridge;


+ (BOOL)requiresMainQueueSetup
{
    return NO;
}
RCT_REMAP_METHOD(release, release:(NSDictionary *)currentInstance withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    [self baseRelease:currentInstance withResolver: resolve rejecter:reject];
}
RCT_REMAP_METHOD(log, logWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    [self baseLogWithResolver:resolve rejecter:reject];
}
RCT_REMAP_METHOD(flush, flushWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    [self baseFlushWithResolver:resolve rejecter:reject];
}
RCT_REMAP_METHOD(isNull, isNull:(NSDictionary *)currentInstance withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject)
{
    [self baseIsNull:currentInstance withResolver:resolve rejecter:reject];
}
-(NSData *) hexStringToData: (NSString *)hexString 
{
    NSMutableData *data= [[NSMutableData alloc] init];
    unsigned char byte;
    char byteChars[3] = {'\0','\0','\0'};
    for (int i = 0; i < ([hexString length] / 2); i++)
    {
        byteChars[0] = [hexString characterAtIndex: i*2];
        byteChars[1] = [hexString characterAtIndex: i*2 + 1];
        byte = strtol(byteChars, NULL, 16);
        [data appendBytes:&byte length:1];
    }
    return data;
}
-(NSString *) dataToHexString: (NSData *)data 
{
    const unsigned char *bytes = (const unsigned char *)data.bytes;
    NSMutableString *hex = [NSMutableString new];
    for (NSInteger i = 0; i < data.length; i++)
    {
        [hex appendFormat:@"%02x", bytes[i]];
    }
    return [hex copy];
}

RCT_REMAP_METHOD(getId,getId:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::getId, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::getId, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    NSString * objcResult = [currentInstanceObj getId];
    NSDictionary *result = @{@"value" : objcResult};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::getId", nil);
        return;
    }

}

RCT_REMAP_METHOD(getType,getType:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::getType, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::getType, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    NSString * objcResult = [currentInstanceObj getType];
    NSDictionary *result = @{@"value" : objcResult};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::getType", nil);
        return;
    }

}

RCT_REMAP_METHOD(getSender,getSender:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::getSender, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::getSender, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    NSString * objcResult = [currentInstanceObj getSender];
    NSDictionary *result = @{@"value" : objcResult};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::getSender", nil);
        return;
    }

}

RCT_REMAP_METHOD(getFee,getFee:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::getFee, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::getFee, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    NSString * objcResult = [currentInstanceObj getFee];
    NSDictionary *result = @{@"value" : objcResult};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::getFee", nil);
        return;
    }

}

RCT_REMAP_METHOD(getNote,getNote:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::getNote, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::getNote, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    NSString * objcResult = [currentInstanceObj getNote];
    NSDictionary *result = @{@"value" : objcResult};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::getNote", nil);
        return;
    }

}

RCT_REMAP_METHOD(getRound,getRound:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::getRound, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::getRound, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    NSString * objcResult = [currentInstanceObj getRound];
    NSDictionary *result = @{@"value" : objcResult};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::getRound", nil);
        return;
    }

}

RCT_REMAP_METHOD(getSenderRewards,getSenderRewards:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::getSenderRewards, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::getSenderRewards, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    NSString * objcResult = [currentInstanceObj getSenderRewards];
    NSDictionary *result = @{@"value" : objcResult};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::getSenderRewards", nil);
        return;
    }

}

RCT_REMAP_METHOD(getReceiverRewards,getReceiverRewards:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::getReceiverRewards, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::getReceiverRewards, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    NSString * objcResult = [currentInstanceObj getReceiverRewards];
    NSDictionary *result = @{@"value" : objcResult};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::getReceiverRewards", nil);
        return;
    }

}

RCT_REMAP_METHOD(getCloseRewards,getCloseRewards:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::getCloseRewards, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::getCloseRewards, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    NSString * objcResult = [currentInstanceObj getCloseRewards];
    NSDictionary *result = @{@"value" : objcResult};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::getCloseRewards", nil);
        return;
    }

}

RCT_REMAP_METHOD(setSender,setSender:(NSDictionary *)currentInstance withParams:(nonnull NSString *)sender withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::setSender, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::setSender, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    [currentInstanceObj setSender:sender];
    resolve(@(YES));

}

RCT_REMAP_METHOD(setFee,setFee:(NSDictionary *)currentInstance withParams:(nonnull NSString *)fee withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::setFee, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::setFee, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    [currentInstanceObj setFee:fee];
    resolve(@(YES));

}

RCT_REMAP_METHOD(setNote,setNote:(NSDictionary *)currentInstance withParams:(nonnull NSString *)note withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::setNote, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::setNote, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    [currentInstanceObj setNote:note];
    resolve(@(YES));

}

RCT_REMAP_METHOD(setPaymentInfo,setPaymentInfo:(NSDictionary *)currentInstance withParams:(NSDictionary *)info withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::setPaymentInfo, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::setPaymentInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGAlgorandPaymentInfo *rctParam_info = (RCTCoreLGAlgorandPaymentInfo *)[self.bridge moduleForName:@"CoreLGAlgorandPaymentInfo"];
    LGAlgorandPaymentInfo *objcParam_0 = (LGAlgorandPaymentInfo *)[rctParam_info.objcImplementations objectForKey:info[@"uid"]];
    [currentInstanceObj setPaymentInfo:objcParam_0];
    resolve(@(YES));

}

RCT_REMAP_METHOD(getPaymentInfo,getPaymentInfo:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::getPaymentInfo, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::getPaymentInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    LGAlgorandPaymentInfo * objcResult = [currentInstanceObj getPaymentInfo];

    NSString *objcResult_uuid = [[NSUUID UUID] UUIDString];
    RCTCoreLGAlgorandPaymentInfo *rctImpl_objcResult = (RCTCoreLGAlgorandPaymentInfo *)[self.bridge moduleForName:@"CoreLGAlgorandPaymentInfo"];
    NSArray *objcResult_array = [[NSArray alloc] initWithObjects:objcResult, objcResult_uuid, nil];
    [rctImpl_objcResult baseSetObject:objcResult_array];
    NSDictionary *result = @{@"type" : @"CoreLGAlgorandPaymentInfo", @"uid" : objcResult_uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::getPaymentInfo", nil);
        return;
    }

}

RCT_REMAP_METHOD(setParticipationInfo,setParticipationInfo:(NSDictionary *)currentInstance withParams:(NSDictionary *)info withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::setParticipationInfo, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::setParticipationInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGAlgorandParticipationInfo *rctParam_info = (RCTCoreLGAlgorandParticipationInfo *)[self.bridge moduleForName:@"CoreLGAlgorandParticipationInfo"];
    LGAlgorandParticipationInfo *objcParam_0 = (LGAlgorandParticipationInfo *)[rctParam_info.objcImplementations objectForKey:info[@"uid"]];
    [currentInstanceObj setParticipationInfo:objcParam_0];
    resolve(@(YES));

}

RCT_REMAP_METHOD(getParticipationInfo,getParticipationInfo:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::getParticipationInfo, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::getParticipationInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    LGAlgorandParticipationInfo * objcResult = [currentInstanceObj getParticipationInfo];

    NSString *objcResult_uuid = [[NSUUID UUID] UUIDString];
    RCTCoreLGAlgorandParticipationInfo *rctImpl_objcResult = (RCTCoreLGAlgorandParticipationInfo *)[self.bridge moduleForName:@"CoreLGAlgorandParticipationInfo"];
    NSArray *objcResult_array = [[NSArray alloc] initWithObjects:objcResult, objcResult_uuid, nil];
    [rctImpl_objcResult baseSetObject:objcResult_array];
    NSDictionary *result = @{@"type" : @"CoreLGAlgorandParticipationInfo", @"uid" : objcResult_uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::getParticipationInfo", nil);
        return;
    }

}

RCT_REMAP_METHOD(setAssetConfigurationInfo,setAssetConfigurationInfo:(NSDictionary *)currentInstance withParams:(NSDictionary *)info withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::setAssetConfigurationInfo, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::setAssetConfigurationInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGAlgorandAssetConfigurationInfo *rctParam_info = (RCTCoreLGAlgorandAssetConfigurationInfo *)[self.bridge moduleForName:@"CoreLGAlgorandAssetConfigurationInfo"];
    LGAlgorandAssetConfigurationInfo *objcParam_0 = (LGAlgorandAssetConfigurationInfo *)[rctParam_info.objcImplementations objectForKey:info[@"uid"]];
    [currentInstanceObj setAssetConfigurationInfo:objcParam_0];
    resolve(@(YES));

}

RCT_REMAP_METHOD(getAssetConfigurationInfo,getAssetConfigurationInfo:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::getAssetConfigurationInfo, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::getAssetConfigurationInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    LGAlgorandAssetConfigurationInfo * objcResult = [currentInstanceObj getAssetConfigurationInfo];

    NSString *objcResult_uuid = [[NSUUID UUID] UUIDString];
    RCTCoreLGAlgorandAssetConfigurationInfo *rctImpl_objcResult = (RCTCoreLGAlgorandAssetConfigurationInfo *)[self.bridge moduleForName:@"CoreLGAlgorandAssetConfigurationInfo"];
    NSArray *objcResult_array = [[NSArray alloc] initWithObjects:objcResult, objcResult_uuid, nil];
    [rctImpl_objcResult baseSetObject:objcResult_array];
    NSDictionary *result = @{@"type" : @"CoreLGAlgorandAssetConfigurationInfo", @"uid" : objcResult_uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::getAssetConfigurationInfo", nil);
        return;
    }

}

RCT_REMAP_METHOD(setAssetTransferInfo,setAssetTransferInfo:(NSDictionary *)currentInstance withParams:(NSDictionary *)info withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::setAssetTransferInfo, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::setAssetTransferInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGAlgorandAssetTransferInfo *rctParam_info = (RCTCoreLGAlgorandAssetTransferInfo *)[self.bridge moduleForName:@"CoreLGAlgorandAssetTransferInfo"];
    LGAlgorandAssetTransferInfo *objcParam_0 = (LGAlgorandAssetTransferInfo *)[rctParam_info.objcImplementations objectForKey:info[@"uid"]];
    [currentInstanceObj setAssetTransferInfo:objcParam_0];
    resolve(@(YES));

}

RCT_REMAP_METHOD(getAssetTransferInfo,getAssetTransferInfo:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::getAssetTransferInfo, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::getAssetTransferInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    LGAlgorandAssetTransferInfo * objcResult = [currentInstanceObj getAssetTransferInfo];

    NSString *objcResult_uuid = [[NSUUID UUID] UUIDString];
    RCTCoreLGAlgorandAssetTransferInfo *rctImpl_objcResult = (RCTCoreLGAlgorandAssetTransferInfo *)[self.bridge moduleForName:@"CoreLGAlgorandAssetTransferInfo"];
    NSArray *objcResult_array = [[NSArray alloc] initWithObjects:objcResult, objcResult_uuid, nil];
    [rctImpl_objcResult baseSetObject:objcResult_array];
    NSDictionary *result = @{@"type" : @"CoreLGAlgorandAssetTransferInfo", @"uid" : objcResult_uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::getAssetTransferInfo", nil);
        return;
    }

}

RCT_REMAP_METHOD(setAssetFreezeInfo,setAssetFreezeInfo:(NSDictionary *)currentInstance withParams:(NSDictionary *)info withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::setAssetFreezeInfo, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::setAssetFreezeInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    RCTCoreLGAlgorandAssetFreezeInfo *rctParam_info = (RCTCoreLGAlgorandAssetFreezeInfo *)[self.bridge moduleForName:@"CoreLGAlgorandAssetFreezeInfo"];
    LGAlgorandAssetFreezeInfo *objcParam_0 = (LGAlgorandAssetFreezeInfo *)[rctParam_info.objcImplementations objectForKey:info[@"uid"]];
    [currentInstanceObj setAssetFreezeInfo:objcParam_0];
    resolve(@(YES));

}

RCT_REMAP_METHOD(getAssetFreezeInfo,getAssetFreezeInfo:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::getAssetFreezeInfo, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::getAssetFreezeInfo, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    LGAlgorandAssetFreezeInfo * objcResult = [currentInstanceObj getAssetFreezeInfo];

    NSString *objcResult_uuid = [[NSUUID UUID] UUIDString];
    RCTCoreLGAlgorandAssetFreezeInfo *rctImpl_objcResult = (RCTCoreLGAlgorandAssetFreezeInfo *)[self.bridge moduleForName:@"CoreLGAlgorandAssetFreezeInfo"];
    NSArray *objcResult_array = [[NSArray alloc] initWithObjects:objcResult, objcResult_uuid, nil];
    [rctImpl_objcResult baseSetObject:objcResult_array];
    NSDictionary *result = @{@"type" : @"CoreLGAlgorandAssetFreezeInfo", @"uid" : objcResult_uuid };

    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::getAssetFreezeInfo", nil);
        return;
    }

}

/** Serialize the transaction in MsgPack format */
RCT_REMAP_METHOD(serialize,serialize:(NSDictionary *)currentInstance WithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::serialize, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::serialize, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    NSData * objcResult = [currentInstanceObj serialize];
    NSString *objcResultData = [self dataToHexString:objcResult];
    NSDictionary *result = @{@"value" : objcResultData};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAlgorandTransaction::serialize", nil);
        return;
    }

}

RCT_REMAP_METHOD(setSignature,setSignature:(NSDictionary *)currentInstance withParams:(NSString *)signature withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {
    if (!currentInstance[@"uid"] || !currentInstance[@"type"])
    {
        reject(@"impl_call_error", @"Error while calling RCTCoreLGAlgorandTransaction::setSignature, first argument should be an instance of LGAlgorandTransaction", nil);
        return;
    }
    LGAlgorandTransaction *currentInstanceObj = nil;
    @synchronized(self)
    {
        currentInstanceObj = [self.objcImplementations objectForKey:currentInstance[@"uid"]];
    }
    if (!currentInstanceObj)
    {
        NSString *error = [NSString stringWithFormat:@"Error while calling LGAlgorandTransaction::setSignature, instance of uid %@ not found", currentInstance[@"uid"]];
        reject(@"impl_call_error", error, nil);
        return;
    }
    NSData *objcParam_0 = [self hexStringToData:signature];

    [currentInstanceObj setSignature:objcParam_0];
    resolve(@(YES));

}
@end
